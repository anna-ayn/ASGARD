
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Comparator;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\101\000\002\002\004\000\002\023\004\000\002\020" +
    "\011\000\002\020\005\000\002\015\003\000\002\002\003" +
    "\000\002\002\005\000\002\005\002\000\002\005\003\000" +
    "\002\005\003\000\002\005\003\000\002\005\003\000\002" +
    "\005\003\000\002\005\003\000\002\005\003\000\002\012" +
    "\005\000\002\010\006\000\002\010\007\000\002\011\010" +
    "\000\002\011\011\000\002\011\013\000\002\011\014\000" +
    "\002\007\006\000\002\007\007\000\002\007\010\000\002" +
    "\007\007\000\002\007\011\000\002\014\004\000\002\013" +
    "\004\000\002\004\003\000\002\004\003\000\002\004\004" +
    "\000\002\004\005\000\002\004\005\000\002\004\005\000" +
    "\002\004\005\000\002\004\005\000\002\004\005\000\002" +
    "\004\004\000\002\004\003\000\002\004\003\000\002\004" +
    "\005\000\002\004\005\000\002\004\005\000\002\004\005" +
    "\000\002\004\005\000\002\004\005\000\002\004\005\000" +
    "\002\004\005\000\002\004\003\000\002\004\004\000\002" +
    "\004\004\000\002\004\005\000\002\004\005\000\002\006" +
    "\007\000\002\006\005\000\002\017\005\000\002\017\003" +
    "\000\002\003\003\000\002\003\003\000\002\003\003\000" +
    "\002\016\004\000\002\021\002\000\002\022\002\000\002" +
    "\024\002" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\203\000\006\035\uffc1\037\uffc1\001\002\000\004\002" +
    "\205\001\002\000\006\035\007\037\006\001\002\000\030" +
    "\005\ufffa\035\007\037\006\040\ufffa\044\041\047\027\051" +
    "\031\054\042\055\032\056\043\061\047\001\002\000\004" +
    "\061\uffc3\001\002\000\004\002\000\001\002\000\004\061" +
    "\013\001\002\000\006\004\020\036\201\001\002\000\006" +
    "\004\uffc8\036\uffc8\001\002\000\006\005\016\037\015\001" +
    "\002\000\030\005\ufffa\035\007\037\006\040\ufffa\044\041" +
    "\047\027\051\031\054\042\055\032\056\043\061\047\001" +
    "\002\000\004\061\013\001\002\000\006\004\020\036\021" +
    "\001\002\000\004\061\026\001\002\000\010\041\023\042" +
    "\022\043\025\001\002\000\006\005\uffc7\037\uffc7\001\002" +
    "\000\006\005\uffc6\037\uffc6\001\002\000\006\005\uffcb\037" +
    "\uffcb\001\002\000\006\005\uffc5\037\uffc5\001\002\000\006" +
    "\004\uffc9\036\uffc9\001\002\000\022\006\056\011\060\030" +
    "\051\033\053\034\061\057\054\060\052\061\057\001\002" +
    "\000\012\005\ufff7\040\ufff7\046\ufff7\052\ufff7\001\002\000" +
    "\022\006\056\011\060\030\051\033\053\034\061\057\054" +
    "\060\052\061\057\001\002\000\004\061\164\001\002\000" +
    "\012\005\ufff6\040\ufff6\046\ufff6\052\ufff6\001\002\000\012" +
    "\005\ufffc\040\ufffc\046\ufffc\052\ufffc\001\002\000\004\040" +
    "\162\001\002\000\012\005\ufff8\040\ufff8\046\ufff8\052\ufff8" +
    "\001\002\000\012\005\160\040\ufffd\046\ufffd\052\ufffd\001" +
    "\002\000\012\005\ufff5\040\ufff5\046\ufff5\052\ufff5\001\002" +
    "\000\022\006\056\011\060\030\051\033\053\034\061\057" +
    "\054\060\052\061\057\001\002\000\004\061\uffc3\001\002" +
    "\000\022\006\056\011\060\030\051\033\053\034\061\057" +
    "\054\060\052\061\057\001\002\000\012\005\ufff3\040\ufff3" +
    "\046\ufff3\052\ufff3\001\002\000\012\005\ufff4\040\ufff4\046" +
    "\ufff4\052\ufff4\001\002\000\012\005\ufff9\040\ufff9\046\ufff9" +
    "\052\ufff9\001\002\000\004\032\050\001\002\000\022\006" +
    "\056\011\060\030\051\033\053\034\061\057\054\060\052" +
    "\061\057\001\002\000\022\006\056\011\060\030\051\033" +
    "\053\034\061\057\054\060\052\061\057\001\002\000\064" +
    "\005\uffda\007\uffda\010\uffda\011\uffda\012\uffda\013\uffda\014" +
    "\uffda\015\uffda\016\uffda\017\uffda\020\uffda\021\uffda\022\uffda" +
    "\023\uffda\024\uffda\025\uffda\026\uffda\027\uffda\031\uffda\040" +
    "\uffda\045\uffda\046\uffda\050\uffda\052\uffda\053\uffda\001\002" +
    "\000\064\005\uffe3\007\uffe3\010\uffe3\011\uffe3\012\uffe3\013" +
    "\uffe3\014\uffe3\015\uffe3\016\uffe3\017\uffe3\020\uffe3\021\uffe3" +
    "\022\uffe3\023\uffe3\024\uffe3\025\uffe3\026\uffe3\027\uffe3\031" +
    "\uffe3\040\uffe3\045\uffe3\046\uffe3\050\uffe3\052\uffe3\053\uffe3" +
    "\001\002\000\064\005\uffd9\007\uffd9\010\uffd9\011\uffd9\012" +
    "\uffd9\013\uffd9\014\uffd9\015\uffd9\016\uffd9\017\uffd9\020\uffd9" +
    "\021\uffd9\022\uffd9\023\uffd9\024\uffd9\025\uffd9\026\uffd9\027" +
    "\uffd9\031\uffd9\040\uffd9\045\uffd9\046\uffd9\050\uffd9\052\uffd9" +
    "\053\uffd9\001\002\000\054\005\ufff2\010\076\011\075\012" +
    "\065\013\102\014\072\015\071\016\070\017\067\020\077" +
    "\021\103\022\063\023\064\024\066\025\073\026\074\027" +
    "\101\031\100\040\ufff2\046\ufff2\052\ufff2\001\002\000\022" +
    "\006\056\011\060\030\051\033\053\034\061\057\054\060" +
    "\052\061\057\001\002\000\064\005\uffe4\007\uffe4\010\uffe4" +
    "\011\uffe4\012\uffe4\013\uffe4\014\uffe4\015\uffe4\016\uffe4\017" +
    "\uffe4\020\uffe4\021\uffe4\022\uffe4\023\uffe4\024\uffe4\025\uffe4" +
    "\026\uffe4\027\uffe4\031\uffe4\040\uffe4\045\uffe4\046\uffe4\050" +
    "\uffe4\052\uffe4\053\uffe4\001\002\000\022\006\056\011\060" +
    "\030\051\033\053\034\061\057\054\060\052\061\057\001" +
    "\002\000\064\005\uffd0\007\uffd0\010\uffd0\011\uffd0\012\uffd0" +
    "\013\uffd0\014\uffd0\015\uffd0\016\uffd0\017\uffd0\020\uffd0\021" +
    "\uffd0\022\uffd0\023\uffd0\024\uffd0\025\uffd0\026\uffd0\027\uffd0" +
    "\031\uffd0\040\uffd0\045\uffd0\046\uffd0\050\uffd0\052\uffd0\053" +
    "\uffd0\001\002\000\064\005\uffe2\007\uffe2\010\uffe2\011\uffe2" +
    "\012\uffe2\013\uffe2\014\uffe2\015\uffe2\016\uffe2\017\uffe2\020" +
    "\uffe2\021\uffe2\022\uffe2\023\uffe2\024\uffe2\025\uffe2\026\074" +
    "\027\101\031\100\040\uffe2\045\uffe2\046\uffe2\050\uffe2\052" +
    "\uffe2\053\uffe2\001\002\000\022\006\056\011\060\030\051" +
    "\033\053\034\061\057\054\060\052\061\057\001\002\000" +
    "\022\006\056\011\060\030\051\033\053\034\061\057\054" +
    "\060\052\061\057\001\002\000\022\006\056\011\060\030" +
    "\051\033\053\034\061\057\054\060\052\061\057\001\002" +
    "\000\022\006\056\011\060\030\051\033\053\034\061\057" +
    "\054\060\052\061\057\001\002\000\064\005\uffdb\007\uffdb" +
    "\010\uffdb\011\uffdb\012\uffdb\013\uffdb\014\uffdb\015\uffdb\016" +
    "\uffdb\017\uffdb\020\uffdb\021\uffdb\022\uffdb\023\uffdb\024\uffdb" +
    "\025\uffdb\026\uffdb\027\uffdb\031\uffdb\040\uffdb\045\uffdb\046" +
    "\uffdb\050\uffdb\052\uffdb\053\uffdb\001\002\000\022\006\056" +
    "\011\060\030\051\033\053\034\061\057\054\060\052\061" +
    "\057\001\002\000\022\006\056\011\060\030\051\033\053" +
    "\034\061\057\054\060\052\061\057\001\002\000\022\006" +
    "\056\011\060\030\051\033\053\034\061\057\054\060\052" +
    "\061\057\001\002\000\022\006\056\011\060\030\051\033" +
    "\053\034\061\057\054\060\052\061\057\001\002\000\022" +
    "\006\056\011\060\030\051\033\053\034\061\057\054\060" +
    "\052\061\057\001\002\000\022\006\056\011\060\030\051" +
    "\033\053\034\061\057\054\060\052\061\057\001\002\000" +
    "\022\006\056\011\060\030\051\033\053\034\061\057\054" +
    "\060\052\061\057\001\002\000\022\006\056\011\060\030" +
    "\051\033\053\034\061\057\054\060\052\061\057\001\002" +
    "\000\064\005\uffcf\007\uffcf\010\uffcf\011\uffcf\012\uffcf\013" +
    "\uffcf\014\uffcf\015\uffcf\016\uffcf\017\uffcf\020\uffcf\021\uffcf" +
    "\022\uffcf\023\uffcf\024\uffcf\025\uffcf\026\uffcf\027\uffcf\031" +
    "\uffcf\040\uffcf\045\uffcf\046\uffcf\050\uffcf\052\uffcf\053\uffcf" +
    "\001\002\000\022\006\056\011\060\030\051\033\053\034" +
    "\061\057\054\060\052\061\057\001\002\000\022\006\056" +
    "\011\060\030\051\033\053\034\061\057\054\060\052\061" +
    "\057\001\002\000\022\006\056\011\060\030\051\033\053" +
    "\034\061\057\054\060\052\061\057\001\002\000\064\005" +
    "\uffd3\007\uffd3\010\076\011\075\012\065\013\102\014\072" +
    "\015\uffd3\016\uffd3\017\uffd3\020\uffd3\021\uffd3\022\uffd3\023" +
    "\uffd3\024\uffd3\025\uffd3\026\074\027\101\031\100\040\uffd3" +
    "\045\uffd3\046\uffd3\050\uffd3\052\uffd3\053\uffd3\001\002\000" +
    "\064\005\uffde\007\uffde\010\uffde\011\uffde\012\uffde\013\uffde" +
    "\014\uffde\015\uffde\016\uffde\017\uffde\020\uffde\021\uffde\022" +
    "\uffde\023\uffde\024\uffde\025\uffde\026\074\027\101\031\100" +
    "\040\uffde\045\uffde\046\uffde\050\uffde\052\uffde\053\uffde\001" +
    "\002\000\064\005\uffcc\007\uffcc\010\uffcc\011\uffcc\012\uffcc" +
    "\013\uffcc\014\uffcc\015\uffcc\016\uffcc\017\uffcc\020\uffcc\021" +
    "\uffcc\022\uffcc\023\uffcc\024\uffcc\025\uffcc\026\uffcc\027\uffcc" +
    "\031\100\040\uffcc\045\uffcc\046\uffcc\050\uffcc\052\uffcc\053" +
    "\uffcc\001\002\000\064\005\uffd4\007\uffd4\010\076\011\075" +
    "\012\065\013\102\014\072\015\uffd4\016\uffd4\017\uffd4\020" +
    "\uffd4\021\uffd4\022\uffd4\023\uffd4\024\uffd4\025\uffd4\026\074" +
    "\027\101\031\100\040\uffd4\045\uffd4\046\uffd4\050\uffd4\052" +
    "\uffd4\053\uffd4\001\002\000\064\005\uffe1\007\uffe1\010\uffe1" +
    "\011\uffe1\012\065\013\102\014\072\015\uffe1\016\uffe1\017" +
    "\uffe1\020\uffe1\021\uffe1\022\uffe1\023\uffe1\024\uffe1\025\uffe1" +
    "\026\074\027\101\031\100\040\uffe1\045\uffe1\046\uffe1\050" +
    "\uffe1\052\uffe1\053\uffe1\001\002\000\064\005\uffe0\007\uffe0" +
    "\010\uffe0\011\uffe0\012\065\013\102\014\072\015\uffe0\016" +
    "\uffe0\017\uffe0\020\uffe0\021\uffe0\022\uffe0\023\uffe0\024\uffe0" +
    "\025\uffe0\026\074\027\101\031\100\040\uffe0\045\uffe0\046" +
    "\uffe0\050\uffe0\052\uffe0\053\uffe0\001\002\000\064\005\uffcd" +
    "\007\uffcd\010\uffcd\011\uffcd\012\uffcd\013\uffcd\014\uffcd\015" +
    "\uffcd\016\uffcd\017\uffcd\020\uffcd\021\uffcd\022\uffcd\023\uffcd" +
    "\024\uffcd\025\uffcd\026\uffcd\027\uffcd\031\100\040\uffcd\045" +
    "\uffcd\046\uffcd\050\uffcd\052\uffcd\053\uffcd\001\002\000\064" +
    "\005\uffd5\007\uffd5\010\076\011\075\012\065\013\102\014" +
    "\072\015\uffd5\016\uffd5\017\uffd5\020\077\021\103\022\063" +
    "\023\064\024\uffd5\025\uffd5\026\074\027\101\031\100\040" +
    "\uffd5\045\uffd5\046\uffd5\050\uffd5\052\uffd5\053\uffd5\001\002" +
    "\000\064\005\uffdd\007\uffdd\010\uffdd\011\uffdd\012\uffdd\013" +
    "\uffdd\014\uffdd\015\uffdd\016\uffdd\017\uffdd\020\uffdd\021\uffdd" +
    "\022\uffdd\023\uffdd\024\uffdd\025\uffdd\026\074\027\101\031" +
    "\100\040\uffdd\045\uffdd\046\uffdd\050\uffdd\052\uffdd\053\uffdd" +
    "\001\002\000\064\005\uffd8\007\uffd8\010\076\011\075\012" +
    "\065\013\102\014\072\015\uffd8\016\uffd8\017\067\020\077" +
    "\021\103\022\063\023\064\024\066\025\073\026\074\027" +
    "\101\031\100\040\uffd8\045\uffd8\046\uffd8\050\uffd8\052\uffd8" +
    "\053\uffd8\001\002\000\064\005\uffd7\007\uffd7\010\076\011" +
    "\075\012\065\013\102\014\072\015\071\016\uffd7\017\067" +
    "\020\077\021\103\022\063\023\064\024\066\025\073\026" +
    "\074\027\101\031\100\040\uffd7\045\uffd7\046\uffd7\050\uffd7" +
    "\052\uffd7\053\uffd7\001\002\000\064\005\uffd6\007\uffd6\010" +
    "\076\011\075\012\065\013\102\014\072\015\uffd6\016\uffd6" +
    "\017\uffd6\020\077\021\103\022\063\023\064\024\uffd6\025" +
    "\uffd6\026\074\027\101\031\100\040\uffd6\045\uffd6\046\uffd6" +
    "\050\uffd6\052\uffd6\053\uffd6\001\002\000\064\005\uffdf\007" +
    "\uffdf\010\uffdf\011\uffdf\012\uffdf\013\uffdf\014\uffdf\015\uffdf" +
    "\016\uffdf\017\uffdf\020\uffdf\021\uffdf\022\uffdf\023\uffdf\024" +
    "\uffdf\025\uffdf\026\074\027\101\031\100\040\uffdf\045\uffdf" +
    "\046\uffdf\050\uffdf\052\uffdf\053\uffdf\001\002\000\064\005" +
    "\uffd1\007\uffd1\010\076\011\075\012\065\013\102\014\072" +
    "\015\uffd1\016\uffd1\017\uffd1\020\uffd1\021\uffd1\022\uffd1\023" +
    "\uffd1\024\uffd1\025\uffd1\026\074\027\101\031\100\040\uffd1" +
    "\045\uffd1\046\uffd1\050\uffd1\052\uffd1\053\uffd1\001\002\000" +
    "\064\005\uffd2\007\uffd2\010\076\011\075\012\065\013\102" +
    "\014\072\015\uffd2\016\uffd2\017\uffd2\020\uffd2\021\uffd2\022" +
    "\uffd2\023\uffd2\024\uffd2\025\uffd2\026\074\027\101\031\100" +
    "\040\uffd2\045\uffd2\046\uffd2\050\uffd2\052\uffd2\053\uffd2\001" +
    "\002\000\046\007\124\010\076\011\075\012\065\013\102" +
    "\014\072\015\071\016\070\017\067\020\077\021\103\022" +
    "\063\023\064\024\066\025\073\026\074\027\101\031\100" +
    "\001\002\000\064\005\uffdc\007\uffdc\010\uffdc\011\uffdc\012" +
    "\uffdc\013\uffdc\014\uffdc\015\uffdc\016\uffdc\017\uffdc\020\uffdc" +
    "\021\uffdc\022\uffdc\023\uffdc\024\uffdc\025\uffdc\026\uffdc\027" +
    "\uffdc\031\uffdc\040\uffdc\045\uffdc\046\uffdc\050\uffdc\052\uffdc" +
    "\053\uffdc\001\002\000\064\005\uffce\007\uffce\010\uffce\011" +
    "\uffce\012\uffce\013\uffce\014\uffce\015\uffce\016\uffce\017\uffce" +
    "\020\uffce\021\uffce\022\uffce\023\uffce\024\uffce\025\uffce\026" +
    "\uffce\027\uffce\031\100\040\uffce\045\uffce\046\uffce\050\uffce" +
    "\052\uffce\053\uffce\001\002\000\054\005\uffe6\010\076\011" +
    "\075\012\065\013\102\014\072\015\071\016\070\017\067" +
    "\020\077\021\103\022\063\023\064\024\066\025\073\026" +
    "\074\027\101\031\100\040\uffe6\046\uffe6\052\uffe6\001\002" +
    "\000\004\061\131\001\002\000\022\006\056\011\060\030" +
    "\051\033\053\034\061\057\054\060\052\061\057\001\002" +
    "\000\004\051\132\001\002\000\022\006\uffc4\011\uffc4\030" +
    "\uffc4\033\uffc4\034\uffc4\057\uffc4\060\uffc4\061\uffc4\001\002" +
    "\000\046\010\076\011\075\012\065\013\102\014\072\015" +
    "\071\016\070\017\067\020\077\021\103\022\063\023\064" +
    "\024\066\025\073\026\074\027\101\031\100\050\134\001" +
    "\002\000\022\006\056\011\060\030\051\033\053\034\061" +
    "\057\054\060\052\061\057\001\002\000\046\010\076\011" +
    "\075\012\065\013\102\014\072\015\071\016\070\017\067" +
    "\020\077\021\103\022\063\023\064\024\066\025\073\026" +
    "\074\027\101\031\100\053\136\001\002\000\030\005\ufffa" +
    "\035\007\037\006\044\041\047\027\051\031\052\137\054" +
    "\042\055\032\056\043\061\047\001\002\000\012\005\uffc2" +
    "\040\uffc2\046\uffc2\052\uffc2\001\002\000\004\052\141\001" +
    "\002\000\012\005\uffc2\040\uffc2\046\uffc2\052\uffc2\001\002" +
    "\000\012\005\uffec\040\uffec\046\uffec\052\uffec\001\002\000" +
    "\012\005\uffed\040\uffed\046\uffed\052\uffed\001\002\000\046" +
    "\010\076\011\075\012\065\013\102\014\072\015\071\016" +
    "\070\017\067\020\077\021\103\022\063\023\064\024\066" +
    "\025\073\026\074\027\101\031\100\045\145\001\002\000" +
    "\032\005\ufffa\035\007\037\006\044\041\046\150\047\027" +
    "\051\031\052\146\054\042\055\032\056\043\061\047\001" +
    "\002\000\012\005\uffeb\040\uffeb\046\uffeb\052\uffeb\001\002" +
    "\000\006\046\154\052\155\001\002\000\030\005\ufffa\035" +
    "\007\037\006\044\041\047\027\051\031\052\151\054\042" +
    "\055\032\056\043\061\047\001\002\000\012\005\uffe8\040" +
    "\uffe8\046\uffe8\052\uffe8\001\002\000\004\052\153\001\002" +
    "\000\012\005\uffe9\040\uffe9\046\uffe9\052\uffe9\001\002\000" +
    "\030\005\ufffa\035\007\037\006\044\041\047\027\051\031" +
    "\052\ufffa\054\042\055\032\056\043\061\047\001\002\000" +
    "\012\005\uffea\040\uffea\046\uffea\052\uffea\001\002\000\004" +
    "\052\157\001\002\000\012\005\uffe7\040\uffe7\046\uffe7\052" +
    "\uffe7\001\002\000\034\005\ufffa\035\007\037\006\040\ufffa" +
    "\044\041\046\ufffa\047\027\051\031\052\ufffa\054\042\055" +
    "\032\056\043\061\047\001\002\000\012\005\ufffb\040\ufffb" +
    "\046\ufffb\052\ufffb\001\002\000\014\002\uffc2\005\uffc2\040" +
    "\uffc2\046\uffc2\052\uffc2\001\002\000\014\002\uffff\005\uffff" +
    "\040\uffff\046\uffff\052\uffff\001\002\000\012\005\uffe5\040" +
    "\uffe5\046\uffe5\052\uffe5\001\002\000\046\010\076\011\075" +
    "\012\065\013\102\014\072\015\071\016\070\017\067\020" +
    "\077\021\103\022\063\023\064\024\066\025\073\026\074" +
    "\027\101\031\100\050\166\001\002\000\022\006\056\011" +
    "\060\030\051\033\053\034\061\057\054\060\052\061\057" +
    "\001\002\000\046\010\076\011\075\012\065\013\102\014" +
    "\072\015\071\016\070\017\067\020\077\021\103\022\063" +
    "\023\064\024\066\025\073\026\074\027\101\031\100\053" +
    "\170\001\002\000\030\005\ufffa\035\007\037\006\044\041" +
    "\047\027\051\031\052\171\054\042\055\032\056\043\061" +
    "\047\001\002\000\012\005\uffef\040\uffef\046\uffef\052\uffef" +
    "\001\002\000\004\052\173\001\002\000\012\005\uffee\040" +
    "\uffee\046\uffee\052\uffee\001\002\000\046\010\076\011\075" +
    "\012\065\013\102\014\072\015\071\016\070\017\067\020" +
    "\077\021\103\022\063\023\064\024\066\025\073\026\074" +
    "\027\101\031\100\053\175\001\002\000\030\005\ufffa\035" +
    "\007\037\006\044\041\047\027\051\031\052\176\054\042" +
    "\055\032\056\043\061\047\001\002\000\012\005\ufff1\040" +
    "\ufff1\046\ufff1\052\ufff1\001\002\000\004\052\200\001\002" +
    "\000\012\005\ufff0\040\ufff0\046\ufff0\052\ufff0\001\002\000" +
    "\010\041\023\042\022\043\025\001\002\000\006\005\uffca" +
    "\037\uffca\001\002\000\004\040\204\001\002\000\014\002" +
    "\ufffe\005\ufffe\040\ufffe\046\ufffe\052\ufffe\001\002\000\004" +
    "\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\203\000\006\023\003\024\004\001\001\000\002\001" +
    "\001\000\004\020\007\001\001\000\026\002\036\005\033" +
    "\007\032\010\027\011\035\012\037\013\044\014\043\015" +
    "\202\020\045\001\001\000\004\021\010\001\001\000\002" +
    "\001\001\000\006\006\013\017\011\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\026\002\036" +
    "\005\033\007\032\010\027\011\035\012\037\013\044\014" +
    "\043\015\034\020\045\001\001\000\004\017\016\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\003\023\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\004\173\001" +
    "\001\000\002\001\001\000\004\004\164\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\004\143\001\001\000\004\021\126\001\001\000" +
    "\004\004\125\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\004\054\001" +
    "\001\000\004\004\124\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\004" +
    "\122\001\001\000\002\001\001\000\004\004\061\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\004\121\001" +
    "\001\000\004\004\120\001\001\000\004\004\117\001\001" +
    "\000\004\004\116\001\001\000\002\001\001\000\004\004" +
    "\115\001\001\000\004\004\114\001\001\000\004\004\113" +
    "\001\001\000\004\004\112\001\001\000\004\004\111\001" +
    "\001\000\004\004\110\001\001\000\004\004\107\001\001" +
    "\000\004\004\106\001\001\000\002\001\001\000\004\004" +
    "\105\001\001\000\004\004\104\001\001\000\004\004\103" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\016\127\001\001\000\004\004\132\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\004\134\001\001\000\002\001\001\000\026\002\036\005" +
    "\033\007\032\010\027\011\035\012\037\013\044\014\043" +
    "\015\137\020\045\001\001\000\004\022\142\001\001\000" +
    "\002\001\001\000\004\022\141\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\026\002\036\005" +
    "\033\007\032\010\027\011\035\012\037\013\044\014\043" +
    "\015\146\020\045\001\001\000\002\001\001\000\002\001" +
    "\001\000\026\002\036\005\033\007\032\010\027\011\035" +
    "\012\037\013\044\014\043\015\151\020\045\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\026" +
    "\002\036\005\033\007\032\010\027\011\035\012\037\013" +
    "\044\014\043\015\155\020\045\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\022\005\160\007" +
    "\032\010\027\011\035\012\037\013\044\014\043\020\045" +
    "\001\001\000\002\001\001\000\004\022\162\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\004\166\001\001\000\002\001\001\000\026\002\036\005" +
    "\033\007\032\010\027\011\035\012\037\013\044\014\043" +
    "\015\171\020\045\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\026\002\036" +
    "\005\033\007\032\010\027\011\035\012\037\013\044\014" +
    "\043\015\176\020\045\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\003\201\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    /* Priority Queue para los errores de contexto */
    public PriorityQueue<Pair> errors_queue = new PriorityQueue<>(Comparator.comparingInt(Pair::getFila));

    /* Tabla de Simbolos del programa Asgard */
    public SymbolTable tablaActual;

    /**
     * Método al que se llama automáticamente ante algún error sintactico.
     * Se imprime solamente el primer error.
     **/
    public void syntax_error(Symbol s){ 
        System.out.println("Error sintáctico en la línea " + (s.left) +
        ", columna "+ s.right + ".");
        System.exit(1);
    }

    /* Metodo al que se llama automaticamente ante algun error de contexto
    Se guarda en una cola estos errores
    */
    public void context_error(int sleft, int sright, String mensaje){
        String error = "Error de contexto en la línea " + (sleft) +
        ", columna "+ sright + ". " + mensaje + ".";
        errors_queue.add(new Pair(sleft, error));
    }

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores. 
     * NOTA: No se realiza ninguna acción.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{  
    }

    


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {


    /*Arbol Sintactico del programa*/
    ASTNode program;

    public void finalizar() {
        program.Interpretar();
    }

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= programa EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // programa ::= iniciarAlcance alcance 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		/*Inicializar el arbol sintactico abstracto*/
                                       program = new DefaultNode((ASTNode) a); 
                                       /* Si la cola de errores de contexto no esta vacia*/
                                       if (!errors_queue.isEmpty()) { 
                                                /* se imprime la cola de errores*/
                                                System.out.println("Se encontraron los siguientes errores de contexto: \n");
                                               while (!errors_queue.isEmpty()) {
                                                        Pair x = errors_queue.poll();
                                                        System.out.println(x.getMsg());
                                                } 
                                       } else {
                                                finalizar();
                                       }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("programa",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // alcance ::= TkUsing abrirAlcance decIdentificadores TkBegin bloque TkEnd cerrarAlcance 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                        RESULT = errors_queue.isEmpty() ? new DefaultNode((ASTNode) a) : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("alcance",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // alcance ::= TkBegin bloque TkEnd 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = errors_queue.isEmpty() ? new DefaultNode((ASTNode) a) : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("alcance",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // bloque ::= secuenciacion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = errors_queue.isEmpty() ? new Secuenciacion((Instruccion) a) : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // secuenciacion ::= instruccion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = errors_queue.isEmpty() ? new Instruccion((ASTNode) a) : new Undefined();
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuenciacion",0, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // secuenciacion ::= secuenciacion TkPuntoYComa instruccion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        RESULT = errors_queue.isEmpty() ?  new Instruccion((ASTNode) a, (ASTNode) b) : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("secuenciacion",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // instruccion ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // instruccion ::= alcance 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = errors_queue.isEmpty() ? (ASTNode) a : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // instruccion ::= IteracionDet 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = errors_queue.isEmpty() ? (IteracionDet) a : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // instruccion ::= IteracionIndet 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = errors_queue.isEmpty() ? (IteracionIndet) a : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // instruccion ::= Condicional 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = errors_queue.isEmpty() ? (Condicional) a : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // instruccion ::= asignVariables 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = errors_queue.isEmpty() ? (Asignacion) a : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // instruccion ::= Lectura 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = errors_queue.isEmpty() ? (Read) a : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // instruccion ::= Escritura 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = errors_queue.isEmpty() ? (Print) a : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("instruccion",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // asignVariables ::= TkIdent TkAsignacion expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                Identificador ident = tablaActual.get(a.toString());
                if(ident != null){
                        /* verificar que la variable que se esta modificando no sea una variable asociada a una repeticion determinada */
                        if (ident.getFlag()) {
                                context_error(aleft, aright, "No se puede modificar el valor de una variable asociada a una repeticion determinada");
                                RESULT = new Undefined();
                        } else {
                                /* verificar si coincide el tipo de dato de expresion de b con el tipo de identificador de a */
                                if(ident.getTipo() == ((Expression) b).getTipo()){
                                        RESULT = new Asignacion(ident, (Expression) b);
                                } else {
                                        context_error(aleft, aright, "El tipo de la expresión no coincide con el tipo del identificador");
                                        RESULT = new Asignacion(ident, new Undefined());
                                }
                        }
                } else {
                   context_error(aleft, aright, "El identificador " + a.toString() + " no ha sido declarado");
                   RESULT = new Undefined();
                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignVariables",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // IteracionIndet ::= TkWhile expresion TkRepeat TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                RESULT = errors_queue.isEmpty() ? new IteracionIndet((Expression) a, null) : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("IteracionIndet",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // IteracionIndet ::= TkWhile expresion TkRepeat bloque TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                RESULT = errors_queue.isEmpty() ? new IteracionIndet((Expression) a, (ASTNode) b) : new Undefined(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("IteracionIndet",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // IteracionDet ::= TkFrom expresion TkTo expresion TkRepeat TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                /* verificar que los limites sean expresiones aritmeticas */
                Expression exp1 = (Expression) a;
                Expression exp2 = (Expression) b;

                if (exp1.getTipo() == "undefined" || exp2.getTipo() == "undefined") {
                        context_error(aleft, aright, "Hubo un error con los limites de la iteración determinada");  
                        RESULT = new Undefined();
                } 
                else if (exp1.getTipo() == "integer") {
                        if (exp2.getTipo() == "integer") {
                                RESULT = new IteracionDet(exp1, exp2, null);
                        } else {
                                context_error(aleft, aright, "El limite superior no es una expresión aritmética");  
                                RESULT = new Undefined();
                        }
                } else {
                        context_error(aleft, aright, "El limite inferior no es una expresión aritmética");
                        RESULT = new Undefined(); 
                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("IteracionDet",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // IteracionDet ::= TkFrom expresion TkTo expresion TkRepeat bloque TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                /* verificar que los limites sean expresiones aritmeticas */
                Expression exp1 = (Expression) a;
                Expression exp2 = (Expression) b;

                if (exp1.getTipo() == "undefined" || exp2.getTipo() == "undefined") {
                        context_error(aleft, aright, "Hubo un error con los limites de la iteración determinada");  
                        RESULT = new Undefined();
                } 
                else if (exp1.getTipo() == "integer") {
                        if (exp2.getTipo() == "integer") {
                                RESULT = new IteracionDet(exp1, exp2, (ASTNode) c);
                        } else {
                                context_error(aleft, aright, "El limite superior no es una expresión aritmética");  
                                RESULT = new Undefined();
                        }
                } else {
                        context_error(aleft, aright, "El limite inferior no es una expresión aritmética");
                        RESULT = new Undefined(); 
                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("IteracionDet",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // IteracionDet ::= TkWith abrirAlcance nuevoInteger expresion TkTo expresion TkRepeat TkDone cerrarAlcance 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
                        /* verificar que los limites sean expresiones aritmeticas */
                        Identificador ident = (Identificador) a;
                        Expression exp1 = (Expression) b;
                        Expression exp2 = (Expression) c;
                        if (exp1.getTipo() == "undefined" || exp2.getTipo() == "undefined") {
                                context_error(aleft, aright, "Hubo un error con los limites de la iteración determinada");  
                                RESULT = new Undefined();
                        } 
                        else if (exp1.getTipo() == "integer") {
                                if (exp2.getTipo() == "integer") {
                                        RESULT = new IteracionDet(ident, exp1, exp2, null);
                                } else {
                                        context_error(aleft, aright, "El limite superior no es una expresión aritmética");  
                                        RESULT = new Undefined();
                                }
                        } else {
                                context_error(aleft, aright, "El limite inferior no es una expresión aritmética");
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("IteracionDet",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // IteracionDet ::= TkWith abrirAlcance nuevoInteger expresion TkTo expresion TkRepeat bloque TkDone cerrarAlcance 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                        /* verificar que los limites sean expresiones aritmeticas */
                        Identificador ident = (Identificador) a;
                        Expression exp1 = (Expression) b;
                        Expression exp2 = (Expression) c;
                        if (exp1.getTipo() == "undefined" || exp2.getTipo() == "undefined") {
                                context_error(aleft, aright, "Hubo un error con los limites de la iteración determinada");  
                                RESULT = new Undefined();
                        } 
                        else if (exp1.getTipo() == "integer") {
                                if (exp2.getTipo() == "integer") {
                                        RESULT = new IteracionDet(ident, exp1, exp2,  (ASTNode) d);
                                } else {
                                        context_error(aleft, aright, "El limite superior no es una expresión aritmética");  
                                        RESULT = new Undefined();
                                }
                        } else {
                                context_error(aleft, aright, "El limite inferior no es una expresión aritmética");
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("IteracionDet",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // Condicional ::= TkIf expresion TkThen TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                /* verificar que la guardia sea una expresión booleana */
                Expression exp = (Expression) a;
                if (exp.getTipo() == "undefined") {
                        context_error(aleft, aright, "Hubo un error con la guardia del condicional"); 
                        RESULT = new Undefined(); 
                }
                else if (exp.getTipo() == "boolean") {
                        RESULT = new Condicional((Expression) a);
                } else {
                        context_error(aleft, aright, "La guardia no es una expresión booleana"); 
                        RESULT = new Undefined(); 
                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Condicional",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // Condicional ::= TkIf expresion TkThen bloque TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                /* verificar que la guardia sea una expresión booleana */
                Expression exp = (Expression) a;
                if (exp.getTipo() == "undefined") {
                        context_error(aleft, aright, "Hubo un error con la guardia del condicional"); 
                        RESULT = new Undefined(); 
                }
                else if (exp.getTipo() == "boolean") {
                        RESULT = new Condicional((Expression) a, (ASTNode) b);
                } else {
                        context_error(aleft, aright, "La guardia no es una expresión booleana"); 
                        RESULT = new Undefined(); 
                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Condicional",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // Condicional ::= TkIf expresion TkThen TkOtherwise bloque TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                /* verificar que la guardia sea una expresión booleana */
                Expression exp = (Expression) a;
                if (exp.getTipo() == "undefined") {
                        context_error(aleft, aright, "Hubo un error con la guardia del condicional"); 
                        RESULT = new Undefined(); 
                }
                else if (exp.getTipo() == "boolean") {
                        RESULT = new Condicional(exp, null, (ASTNode) c); 
                } else {
                        context_error(aleft, aright, "La guardia no es una expresión booleana");
                        RESULT = new Undefined(); 
                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Condicional",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // Condicional ::= TkIf expresion TkThen TkOtherwise TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
                /* verificar que la guardia sea una expresión booleana */
                Expression exp = (Expression) a;
                if (exp.getTipo() == "undefined") {
                        context_error(aleft, aright, "Hubo un error con la guardia del condicional"); 
                        RESULT = new Undefined(); 
                }
                else if (exp.getTipo() == "boolean") {
                        RESULT = new Condicional(exp); 
                } else {
                        context_error(aleft, aright, "La guardia no es una expresión booleana");
                        RESULT = new Undefined(); 
                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Condicional",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // Condicional ::= TkIf expresion TkThen bloque TkOtherwise bloque TkDone 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                /* verificar que la guardia sea una expresión booleana */
                Expression exp = (Expression) a;
                if (exp.getTipo() == "undefined") {
                        context_error(aleft, aright, "Hubo un error con la guardia del condicional"); 
                        RESULT = new Undefined(); 
                }
                else if (exp.getTipo() == "boolean") {
                        RESULT = new Condicional(exp, (ASTNode) b, (ASTNode) c); 
                } else {
                        context_error(aleft, aright, "La guardia no es una expresión booleana");
                        RESULT = new Undefined(); 
                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Condicional",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // Escritura ::= TkPrint expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                Expression exp = (Expression) a;
                if (exp.getTipo() == "undefined") {
                        context_error(aleft, aright, "Hubo un error con la expresión que se va a imprimir"); 
                        RESULT = new Undefined(); 
                }
                else {RESULT = new Print((Expression) a);}
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Escritura",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // Lectura ::= TkRead TkIdent 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        Identificador ident = tablaActual.get(a.toString());
                        if(ident != null){
                                /* solamente se puede leer identificadores de tipo entero o booleano */
                                if (ident.getTipo() == "integer" || ident.getTipo() == "boolean") {
                                        RESULT = new Read(ident);
                                } else {
                                        context_error(aleft, aright, "No se puede leer el identificador, ya que " + a.toString() + " no es un entero o un booleano"); 
                                        RESULT = new Undefined();
                                }
                        } else {
                                context_error(aleft, aright, "El identificador " + a.toString() + " no ha sido declarado");
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("Lectura",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // expresion ::= TkIdent 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 Identificador ident = tablaActual.get(a.toString());
                           if(ident != null){
                                RESULT = ident;
                           } else {
                                context_error(aleft, aright, "El identificador " + a.toString() + " no ha sido declarado");
                                RESULT = new Undefined();
                           }
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // expresion ::= TkNumLit 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = new Literal(a.toString(), "integer");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // expresion ::= TkMenos expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                        Expression exp = (Expression) a;
                        if (exp.getTipo() == "integer") {
                                RESULT = new ExpresionAritmeticaUna("Menos Unario", exp);
                        } else {
                                context_error(aleft, aright, "Operación aritmética inválida");  
                                RESULT = new Undefined();
                        }
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // expresion ::= expresion TkMas expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                                RESULT = new ExpresionAritmeticaBin("Suma",(Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación aritmética inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // expresion ::= expresion TkMenos expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                                RESULT = new ExpresionAritmeticaBin("Resta",(Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación aritmética inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // expresion ::= expresion TkMult expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                                RESULT = new ExpresionAritmeticaBin("Multiplicacion",(Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación aritmética inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // expresion ::= expresion TkDiv expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                                RESULT = new ExpresionAritmeticaBin("Division",(Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación aritmética inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // expresion ::= expresion TkMod expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                                RESULT = new ExpresionAritmeticaBin("Modulo",(Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación aritmética inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // expresion ::= TkParAbre expresion TkParCierra 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = (Expression) a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // expresion ::= expresion TkNegacion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		  
                        Expression exp = (Expression) a;
                        if (exp.getTipo() == "boolean") {
                                RESULT =new ExpresionBooleanaUna("Negacion", (Expression) a); 
                        } else {
                                context_error(aleft, aright, "Operación booleana inválida");  
                                RESULT = new Undefined();
                        }
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // expresion ::= TkFalse 
            {
              Object RESULT =null;
		 RESULT = new Literal("false", "boolean");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // expresion ::= TkTrue 
            {
              Object RESULT =null;
		 RESULT = new Literal("true", "boolean");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // expresion ::= expresion TkConjuncion expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "boolean" && exp2.getTipo() == "boolean") {
                                RESULT = new ExpresionBooleanaBin("Conjuncion", (Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación booleana inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // expresion ::= expresion TkDisyuncion expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "boolean" && exp2.getTipo() == "boolean") {
                                RESULT = new ExpresionBooleanaBin("Disyuncion", (Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación booleana inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // expresion ::= expresion TkIgual expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if ((exp1.getTipo() == "boolean" && exp2.getTipo() == "boolean") 
                        || (exp1.getTipo() == "integer" && exp2.getTipo() == "integer")
                        || (exp1.getTipo() == "canvas" && exp2.getTipo() == "canvas") ) {
                                RESULT = new ExpresionRelacional("Igual", (Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación de igualdad inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // expresion ::= expresion TkDesigual expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if ((exp1.getTipo() == "boolean" && exp2.getTipo() == "boolean") 
                        || (exp1.getTipo() == "integer" && exp2.getTipo() == "integer")
                        || (exp1.getTipo() == "canvas" && exp2.getTipo() == "canvas") ) {
                                RESULT = new ExpresionRelacional("Desigual", (Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación de desigualdad inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // expresion ::= expresion TkMenor expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                               RESULT = new ExpresionRelacional("Menor", (Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación relacional inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // expresion ::= expresion TkMenorIgual expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                                RESULT = new ExpresionRelacional("Menor o igual", (Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación relacional inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // expresion ::= expresion TkMayor expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                                RESULT = new ExpresionRelacional("Mayor", (Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación relacional inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // expresion ::= expresion TkMayorIgual expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "integer" && exp2.getTipo() == "integer") {
                                RESULT = new ExpresionRelacional("Mayor o igual", (Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación relacional inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // expresion ::= TkCanvasLit 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Literal(a.toString(), "canvas");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // expresion ::= expresion TkTrasposicion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		  
                        Expression exp = (Expression) a;
                        if (exp.getTipo() == "canvas") {
                                RESULT =new ExpresionCanvasUna("Trasposicion", (Expression) a);
                        } else {
                                context_error(aleft, aright, "Operación de canvas inválida");  
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // expresion ::= TkRotacion expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  
                        Expression exp = (Expression) a;
                        if (exp.getTipo() == "canvas") {
                                RESULT =new ExpresionCanvasUna("Rotacion", (Expression) a);
                        } else {
                                context_error(aleft, aright, "Operación de canvas inválida");  
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // expresion ::= expresion TkConcatHorizontal expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "canvas" && exp2.getTipo() == "canvas") {
                                RESULT = new ExpresionCanvasBin("Concatenacion Horizontal",(Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación de canvas inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // expresion ::= expresion TkConcatVertical expresion 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        Expression exp1 = (Expression) a;
                        Expression exp2 = (Expression) b;
                        if (exp1.getTipo() == "canvas" && exp2.getTipo() == "canvas") {
                                RESULT = new ExpresionCanvasBin("Concatenacion Vertical",(Expression) a, (Expression) b);
                        } else {
                                context_error(aleft, aright, "Operación de canvas inválida"); 
                                RESULT = new Undefined();
                        }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // decIdentificadores ::= decIdentificadores TkPuntoYComa listaIdentificadores TkOfType tipo 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		tablaActual.setType(a.toString());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decIdentificadores",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // decIdentificadores ::= listaIdentificadores TkOfType tipo 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		tablaActual.setType(a.toString());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("decIdentificadores",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // listaIdentificadores ::= listaIdentificadores TkComa TkIdent 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                /*chequear si el identificador esta siendo redeclarado en el mismo alcance */
                                if(!tablaActual.contains(a.toString())) {
                                        Identificador ident = new Identificador(a.toString());
                                        tablaActual.put(a.toString(), ident);
                                }
                                else {
                                        context_error(aleft, aright, "El identificador " + a.toString() + " ya fue declarado");
                                        RESULT = new Undefined();
                                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaIdentificadores",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // listaIdentificadores ::= TkIdent 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 /*chequear si el identificador esta siendo redeclarado en el mismo alcance */
                                if(!tablaActual.contains(a.toString())) {
                                        Identificador ident = new Identificador(a.toString());
                                        tablaActual.put(a.toString(), ident);
                                }
                                else {
                                        context_error(aleft, aright, "El identificador " + a.toString() + " ya fue declarado");
                                        RESULT = new Undefined(); 
                                }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listaIdentificadores",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // tipo ::= TkBoolean 
            {
              Object RESULT =null;
		RESULT = "boolean";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // tipo ::= TkInteger 
            {
              Object RESULT =null;
		RESULT = "integer";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // tipo ::= TkCanvas 
            {
              Object RESULT =null;
		RESULT = "canvas";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // nuevoInteger ::= TkIdent TkFrom 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                                 /*chequear que el identificador no este siendo redeclarado el la misma alcance */
                                 if(!tablaActual.contains(a.toString())) {
                                        Identificador ident = new Identificador(a.toString(), true);
                                        ident.setTipo("integer");
                                        tablaActual.put(a.toString(), ident);
                                         RESULT = ident;
                                 } else {
                                        context_error(aleft, aright, "El identificador " + a.toString() + " ya fue declarado");
                                        RESULT = new Undefined();
                                 }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("nuevoInteger",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // abrirAlcance ::= 
            {
              Object RESULT =null;
		tablaActual = new SymbolTable(tablaActual); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("abrirAlcance",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // cerrarAlcance ::= 
            {
              Object RESULT =null;
		tablaActual = tablaActual.parent;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cerrarAlcance",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // iniciarAlcance ::= 
            {
              Object RESULT =null;
		tablaActual = new SymbolTable(null);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("iniciarAlcance",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
